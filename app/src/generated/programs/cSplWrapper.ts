/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type ReadonlyUint8Array,
} from '@solana/kit';
import {
  type ParsedFreezeAccountInstruction,
  type ParsedInitializeInstruction,
  type ParsedPauseInstruction,
  type ParsedSetAuthorityInstruction,
  type ParsedSetFeesInstruction,
  type ParsedThawAccountInstruction,
  type ParsedUnpauseInstruction,
  type ParsedUnwrapInstruction,
  type ParsedWithdrawFeesInstruction,
  type ParsedWrapInstruction,
} from '../instructions';

export const C_SPL_WRAPPER_PROGRAM_ADDRESS =
  'D3FaNQVD8NZC6CFT1AS8Rq2G26iAGZ19CgLJXNMfGAjY' as Address<'D3FaNQVD8NZC6CFT1AS8Rq2G26iAGZ19CgLJXNMfGAjY'>;

export enum CSplWrapperAccount {
  WrapperConfig,
  WrapperStats,
}

export function identifyCSplWrapperAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): CSplWrapperAccount {
  const data = 'data' in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([83, 239, 35, 66, 9, 218, 15, 226])
      ),
      0
    )
  ) {
    return CSplWrapperAccount.WrapperConfig;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([191, 29, 61, 226, 30, 48, 243, 211])
      ),
      0
    )
  ) {
    return CSplWrapperAccount.WrapperStats;
  }
  throw new Error(
    'The provided account could not be identified as a cSplWrapper account.'
  );
}

export enum CSplWrapperInstruction {
  FreezeAccount,
  Initialize,
  Pause,
  SetAuthority,
  SetFees,
  ThawAccount,
  Unpause,
  Unwrap,
  WithdrawFees,
  Wrap,
}

export function identifyCSplWrapperInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): CSplWrapperInstruction {
  const data = 'data' in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([253, 75, 82, 133, 167, 238, 43, 130])
      ),
      0
    )
  ) {
    return CSplWrapperInstruction.FreezeAccount;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([175, 175, 109, 31, 13, 152, 155, 237])
      ),
      0
    )
  ) {
    return CSplWrapperInstruction.Initialize;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([211, 22, 221, 251, 74, 121, 193, 47])
      ),
      0
    )
  ) {
    return CSplWrapperInstruction.Pause;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([133, 250, 37, 21, 110, 163, 26, 121])
      ),
      0
    )
  ) {
    return CSplWrapperInstruction.SetAuthority;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([137, 178, 49, 58, 0, 245, 242, 190])
      ),
      0
    )
  ) {
    return CSplWrapperInstruction.SetFees;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([115, 152, 79, 213, 213, 169, 184, 35])
      ),
      0
    )
  ) {
    return CSplWrapperInstruction.ThawAccount;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([169, 144, 4, 38, 10, 141, 188, 255])
      ),
      0
    )
  ) {
    return CSplWrapperInstruction.Unpause;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([126, 175, 198, 14, 212, 69, 50, 44])
      ),
      0
    )
  ) {
    return CSplWrapperInstruction.Unwrap;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([198, 212, 171, 109, 144, 215, 174, 89])
      ),
      0
    )
  ) {
    return CSplWrapperInstruction.WithdrawFees;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([178, 40, 10, 189, 228, 129, 186, 140])
      ),
      0
    )
  ) {
    return CSplWrapperInstruction.Wrap;
  }
  throw new Error(
    'The provided instruction could not be identified as a cSplWrapper instruction.'
  );
}

export type ParsedCSplWrapperInstruction<
  TProgram extends string = 'D3FaNQVD8NZC6CFT1AS8Rq2G26iAGZ19CgLJXNMfGAjY',
> =
  | ({
      instructionType: CSplWrapperInstruction.FreezeAccount;
    } & ParsedFreezeAccountInstruction<TProgram>)
  | ({
      instructionType: CSplWrapperInstruction.Initialize;
    } & ParsedInitializeInstruction<TProgram>)
  | ({
      instructionType: CSplWrapperInstruction.Pause;
    } & ParsedPauseInstruction<TProgram>)
  | ({
      instructionType: CSplWrapperInstruction.SetAuthority;
    } & ParsedSetAuthorityInstruction<TProgram>)
  | ({
      instructionType: CSplWrapperInstruction.SetFees;
    } & ParsedSetFeesInstruction<TProgram>)
  | ({
      instructionType: CSplWrapperInstruction.ThawAccount;
    } & ParsedThawAccountInstruction<TProgram>)
  | ({
      instructionType: CSplWrapperInstruction.Unpause;
    } & ParsedUnpauseInstruction<TProgram>)
  | ({
      instructionType: CSplWrapperInstruction.Unwrap;
    } & ParsedUnwrapInstruction<TProgram>)
  | ({
      instructionType: CSplWrapperInstruction.WithdrawFees;
    } & ParsedWithdrawFeesInstruction<TProgram>)
  | ({
      instructionType: CSplWrapperInstruction.Wrap;
    } & ParsedWrapInstruction<TProgram>);
